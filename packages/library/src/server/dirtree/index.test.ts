import assert from "assert"
import path from "path"
import { describe, expect, it } from "vitest"
import { createDefaultConfig } from "../config.js"
import type { NeovimIntegrationDefaultAppName, TestServerConfig } from "../updateTestdirectorySchemaFile.js"
import { Lazy } from "../utilities/Lazy.js"
import { buildSchemaForDirectoryTree, getDirectoryTree } from "./index.js"

describe("dirtree", () => {
  const output = new Lazy(() =>
    getDirectoryTree(path.join(__dirname, "..", "..", "..", "..", "integration-tests", "test-environment"))
  )

  it("can get a list of all the files", () => {
    const result = output.get().allFiles

    assert(result)
    expect(result.length).toBeGreaterThan(1)
    assert(result[0])
    expect(result[0].relativePath).toBeTruthy()
  })

  it("should be able to build a typescript type for the tree", async () => {
    const config: TestServerConfig = {
      ...createDefaultConfig("/my/root/path", {}),
      integrations: {
        neovim: {
          NVIM_APPNAMEs: ["nvim" satisfies NeovimIntegrationDefaultAppName, "nvim_alt"],
        },
      },
    }
    const result = await buildSchemaForDirectoryTree(output.get(), "MyDirectoryTree", config)

    expect(result).toMatchInlineSnapshot(`
      "
      // Note: This file is autogenerated. Do not edit it directly.
      //
      // Describes the contents of the test directory, which is a blueprint for
      // files and directories. Tests can create a unique, safe environment for
      // interacting with the contents of such a directory.
      //
      // Having strong typing for the test directory contents ensures that tests can
      // be written with confidence that the files and directories they expect are
      // actually found. Otherwise the tests are brittle and can break easily.

      import * as z from "zod"

      export const MyDirectoryTreeSchema = z.object({
        name: z.literal("test-environment/"),
        type: z.literal("directory"),
        contents: z.object({
          ".bashrc": z.object({ name: z.literal(".bashrc"), type: z.literal("file") }),
          ".config": z.object({
            name: z.literal(".config/"),
            type: z.literal("directory"),
            contents: z.object({
              ".gitkeep": z.object({ name: z.literal(".gitkeep"), type: z.literal("file") }),
              nvim: z.object({
                name: z.literal("nvim/"),
                type: z.literal("directory"),
                contents: z.object({
                  "init.lua": z.object({ name: z.literal("init.lua"), type: z.literal("file") }),
                  "prepare.lua": z.object({ name: z.literal("prepare.lua"), type: z.literal("file") }),
                }),
              }),
              nvim_alt: z.object({
                name: z.literal("nvim_alt/"),
                type: z.literal("directory"),
                contents: z.object({
                  "init.lua": z.object({ name: z.literal("init.lua"), type: z.literal("file") }),
                  "prepare.lua": z.object({ name: z.literal("prepare.lua"), type: z.literal("file") }),
                }),
              }),
            }),
          }),
          "config-modifications": z.object({
            name: z.literal("config-modifications/"),
            type: z.literal("directory"),
            contents: z.object({
              "add_command_to_count_open_buffers.lua": z.object({
                name: z.literal("add_command_to_count_open_buffers.lua"),
                type: z.literal("file"),
              }),
              "add_command_to_update_buffer_after_timeout.lua": z.object({
                name: z.literal("add_command_to_update_buffer_after_timeout.lua"),
                type: z.literal("file"),
              }),
              "don't_crash_when_modification_contains_unescaped_characters\\".lua": z.object({
                name: z.literal("don't_crash_when_modification_contains_unescaped_characters\\".lua"),
                type: z.literal("file"),
              }),
              subdir: z.object({
                name: z.literal("subdir/"),
                type: z.literal("directory"),
                contents: z.object({
                  "subdir-modification.lua": z.object({
                    name: z.literal("subdir-modification.lua"),
                    type: z.literal("file"),
                  }),
                }),
              }),
            }),
          }),
          "dir with spaces": z.object({
            name: z.literal("dir with spaces/"),
            type: z.literal("directory"),
            contents: z.object({
              "file1.txt": z.object({ name: z.literal("file1.txt"), type: z.literal("file") }),
              "file2.txt": z.object({ name: z.literal("file2.txt"), type: z.literal("file") }),
            }),
          }),
          "file.txt": z.object({ name: z.literal("file.txt"), type: z.literal("file") }),
          "initial-file.txt": z.object({ name: z.literal("initial-file.txt"), type: z.literal("file") }),
          "lua-project": z.object({
            name: z.literal("lua-project/"),
            type: z.literal("directory"),
            contents: z.object({
              ".luarc.json": z.object({ name: z.literal(".luarc.json"), type: z.literal("file") }),
              "config.lua": z.object({ name: z.literal("config.lua"), type: z.literal("file") }),
              "init.lua": z.object({ name: z.literal("init.lua"), type: z.literal("file") }),
            }),
          }),
          "other-subdirectory": z.object({
            name: z.literal("other-subdirectory/"),
            type: z.literal("directory"),
            contents: z.object({
              "other-sub-file.txt": z.object({ name: z.literal("other-sub-file.txt"), type: z.literal("file") }),
            }),
          }),
          routes: z.object({
            name: z.literal("routes/"),
            type: z.literal("directory"),
            contents: z.object({
              "posts.$postId": z.object({
                name: z.literal("posts.$postId/"),
                type: z.literal("directory"),
                contents: z.object({
                  "adjacent-file.txt": z.object({ name: z.literal("adjacent-file.txt"), type: z.literal("file") }),
                  "route.tsx": z.object({ name: z.literal("route.tsx"), type: z.literal("file") }),
                  "should-be-excluded-file.txt": z.object({
                    name: z.literal("should-be-excluded-file.txt"),
                    type: z.literal("file"),
                  }),
                }),
              }),
            }),
          }),
          subdirectory: z.object({
            name: z.literal("subdirectory/"),
            type: z.literal("directory"),
            contents: z.object({
              "subdirectory-file.txt": z.object({ name: z.literal("subdirectory-file.txt"), type: z.literal("file") }),
            }),
          }),
          "symlink-target.txt": z.object({
            name: z.literal("symlink-target.txt"),
            type: z.literal("file-symlink"),
            target: z.literal("symlink-test/symlink-target.txt"),
          }),
          "symlink-test": z.object({
            name: z.literal("symlink-test/"),
            type: z.literal("directory"),
            contents: z.object({
              "symlink-target.txt": z.object({ name: z.literal("symlink-target.txt"), type: z.literal("file") }),
            }),
          }),
        }),
      })

      export const MyDirectoryTreeContentsSchema = MyDirectoryTreeSchema.shape.contents
      export type MyDirectoryTreeContentsSchemaType = z.infer<typeof MyDirectoryTreeSchema>

      export type MyDirectoryTree = MyDirectoryTreeContentsSchemaType["contents"]

      export const testDirectoryFiles = z.enum([
        ".bashrc",
        ".config/.gitkeep",
        ".config/nvim/init.lua",
        ".config/nvim/prepare.lua",
        ".config/nvim",
        ".config/nvim_alt/init.lua",
        ".config/nvim_alt/prepare.lua",
        ".config/nvim_alt",
        ".config",
        "config-modifications/add_command_to_count_open_buffers.lua",
        "config-modifications/add_command_to_update_buffer_after_timeout.lua",
        "config-modifications/don't_crash_when_modification_contains_unescaped_characters\\".lua",
        "config-modifications/subdir/subdir-modification.lua",
        "config-modifications/subdir",
        "config-modifications",
        "dir with spaces/file1.txt",
        "dir with spaces/file2.txt",
        "dir with spaces",
        "file.txt",
        "initial-file.txt",
        "lua-project/.luarc.json",
        "lua-project/config.lua",
        "lua-project/init.lua",
        "lua-project",
        "other-subdirectory/other-sub-file.txt",
        "other-subdirectory",
        "routes/posts.$postId/adjacent-file.txt",
        "routes/posts.$postId/route.tsx",
        "routes/posts.$postId/should-be-excluded-file.txt",
        "routes/posts.$postId",
        "routes",
        "subdirectory/subdirectory-file.txt",
        "subdirectory",
        "symlink-target.txt",
        "symlink-test/symlink-target.txt",
        "symlink-test",
        "."
      ])
      export type MyTestDirectoryFile = z.infer<typeof testDirectoryFiles>
      export type MyNeovimAppName = "nvim" | "nvim_alt""
    `)
  })

  it("creates an empty schema when the directory cannot be read", async () => {
    const config: TestServerConfig = createDefaultConfig("/my/root/path", {})
    const tree = getDirectoryTree("nonexistent")
    const result = await buildSchemaForDirectoryTree(tree, "MyDirectoryTree", config)
    expect(result).toMatchInlineSnapshot(`
      "
      // Note: This file is autogenerated. Do not edit it directly.
      //
      // Describes the contents of the test directory, which is a blueprint for
      // files and directories. Tests can create a unique, safe environment for
      // interacting with the contents of such a directory.
      //
      // Having strong typing for the test directory contents ensures that tests can
      // be written with confidence that the files and directories they expect are
      // actually found. Otherwise the tests are brittle and can break easily.

      import * as z from "zod"

      export const MyDirectoryTreeSchema = z.object({
        type: z.literal("directory"),
        name: z.literal("root"),
        contents: z.object({}),
      })

      export const MyDirectoryTreeContentsSchema = MyDirectoryTreeSchema.shape.contents
      export type MyDirectoryTreeContentsSchemaType = z.infer<typeof MyDirectoryTreeSchema>

      export type MyDirectoryTree = MyDirectoryTreeContentsSchemaType["contents"]

      export const testDirectoryFiles = z.enum([])
      export type MyTestDirectoryFile = z.infer<typeof testDirectoryFiles>
      export type MyNeovimAppName = "nvim""
    `)
  })

  describe("provides type-safe access to NVIM_APPNAMEs", () => {
    // the user can configure the NVIM_APPNAMEs they are using in their
    // configuration. These should be available for them in a type-safe manner so
    // that they have the least possible friction when coding.
    //
    const smallDirectory = path.resolve(__dirname, "../../../../integration-tests/test-environment/other-subdirectory/")

    it("when there is a single name", async () => {
      const config: TestServerConfig = createDefaultConfig("/my/root/path", {})
      assert(config.integrations.neovim.NVIM_APPNAMEs.length === 1)
      const tinytree = getDirectoryTree(smallDirectory)
      const result = await buildSchemaForDirectoryTree(tinytree, "MyDirectoryTree", config)

      expect(result).toMatchInlineSnapshot(`
        "
        // Note: This file is autogenerated. Do not edit it directly.
        //
        // Describes the contents of the test directory, which is a blueprint for
        // files and directories. Tests can create a unique, safe environment for
        // interacting with the contents of such a directory.
        //
        // Having strong typing for the test directory contents ensures that tests can
        // be written with confidence that the files and directories they expect are
        // actually found. Otherwise the tests are brittle and can break easily.

        import * as z from "zod"

        export const MyDirectoryTreeSchema = z.object({
          name: z.literal("other-subdirectory/"),
          type: z.literal("directory"),
          contents: z.object({
            "other-sub-file.txt": z.object({ name: z.literal("other-sub-file.txt"), type: z.literal("file") }),
          }),
        })

        export const MyDirectoryTreeContentsSchema = MyDirectoryTreeSchema.shape.contents
        export type MyDirectoryTreeContentsSchemaType = z.infer<typeof MyDirectoryTreeSchema>

        export type MyDirectoryTree = MyDirectoryTreeContentsSchemaType["contents"]

        export const testDirectoryFiles = z.enum([
          "other-sub-file.txt",
          "."
        ])
        export type MyTestDirectoryFile = z.infer<typeof testDirectoryFiles>
        export type MyNeovimAppName = "nvim""
      `)
      //                               👆🏻 from the default config
    })

    it("when there are multiple names", async () => {
      const config: TestServerConfig = {
        ...createDefaultConfig("/my/root/path", {}),
        integrations: {
          neovim: {
            NVIM_APPNAMEs: ["nvim" satisfies NeovimIntegrationDefaultAppName, "nvim_alt"],
          },
        },
      }
      const tinytree = getDirectoryTree(smallDirectory)
      const result = await buildSchemaForDirectoryTree(tinytree, "MyDirectoryTree", config)

      expect(result).toMatchInlineSnapshot(`
        "
        // Note: This file is autogenerated. Do not edit it directly.
        //
        // Describes the contents of the test directory, which is a blueprint for
        // files and directories. Tests can create a unique, safe environment for
        // interacting with the contents of such a directory.
        //
        // Having strong typing for the test directory contents ensures that tests can
        // be written with confidence that the files and directories they expect are
        // actually found. Otherwise the tests are brittle and can break easily.

        import * as z from "zod"

        export const MyDirectoryTreeSchema = z.object({
          name: z.literal("other-subdirectory/"),
          type: z.literal("directory"),
          contents: z.object({
            "other-sub-file.txt": z.object({ name: z.literal("other-sub-file.txt"), type: z.literal("file") }),
          }),
        })

        export const MyDirectoryTreeContentsSchema = MyDirectoryTreeSchema.shape.contents
        export type MyDirectoryTreeContentsSchemaType = z.infer<typeof MyDirectoryTreeSchema>

        export type MyDirectoryTree = MyDirectoryTreeContentsSchemaType["contents"]

        export const testDirectoryFiles = z.enum([
          "other-sub-file.txt",
          "."
        ])
        export type MyTestDirectoryFile = z.infer<typeof testDirectoryFiles>
        export type MyNeovimAppName = "nvim" | "nvim_alt""
      `)
    })
  })
})
