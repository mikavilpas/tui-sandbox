import assert from "assert"
import type { Dree } from "dree"
import { scan, Type } from "dree"
import { format, resolveConfig } from "prettier"
import { fileURLToPath } from "url"
import { jsonToZod } from "./json-to-zod"

type TreeResult = { dree: Dree; allFiles: Dree[] }

/** Convert a directory tree to a TypeScript type. This is useful for testing
 * as the initial state of the test directory is fully known in tests. */
export function getDirectoryTree(path: string): TreeResult {
  const allFiles: Dree[] = []
  const result = scan(
    path,
    {
      exclude: [/.repro/, /testdirs/],
      hash: false,
      size: false,
      sizeInBytes: false,
    },
    file => {
      allFiles.push(file)
    },
    dir => {
      allFiles.push(dir)
    }
  )

  return { dree: result, allFiles }
}

type FileNode = {
  type: Type.FILE
  name: string
  extension: string | undefined
  stem: string
}
type DirectoryNode = {
  type: Type.DIRECTORY
  name: string
  contents: Record<string, TreeNode>
}

type TreeNode = FileNode | DirectoryNode

export function convertDree(root: Dree): TreeNode {
  if (root.type === Type.FILE) {
    return {
      name: root.name,
      type: root.type,
      extension: root.extension,
      stem: root.extension ? root.name.slice(0, -root.extension.length) : root.name,
    }
  }

  assert(root.children)
  const node: DirectoryNode = {
    name: root.name,
    type: root.type,
    contents: {},
  }
  for (const child of root.children) {
    node.contents[child.name] = convertDree(child)
  }

  return node
}

export async function buildSchemaForDirectoryTree(result: TreeResult, name: string): Promise<string> {
  const root = result.dree
  assert(root.type === Type.DIRECTORY)
  const node = convertDree(root)
  const schema = (await jsonToZod(node, `${name}Schema`)).split("\n")

  const lines = `
// Note: This file is autogenerated. Do not edit it directly.
//
// Describes the contents of the test directory, which is a blueprint for
// files and directories. Tests can create a unique, safe environment for
// interacting with the contents of such a directory.
//
// Having strong typing for the test directory contents ensures that tests can
// be written with confidence that the files and directories they expect are
// actually found. Otherwise the tests are brittle and can break easily.
`.split("\n")

  const allFilePaths = result.allFiles.map(f => f.relativePath)
  const ContentsSchema = `${name}ContentsSchema`
  const ContentsSchemaType = `${name}ContentsSchemaType`
  return [
    ...lines,
    ...schema,
    `export const ${ContentsSchema} = ${name}Schema.shape.contents`,
    `export type ${ContentsSchemaType} = z.infer<typeof ${name}Schema>`,
    "",
    `export type ${name} = ${ContentsSchemaType}["contents"]`,
    "",
    `export const testDirectoryFiles = z.enum(${JSON.stringify(allFilePaths, null, 2)})`,
    `export type MyTestDirectoryFile = z.infer<typeof testDirectoryFiles>`,
  ].join("\n")
}

const __filename = fileURLToPath(import.meta.url)

export async function buildTestDirectorySchema(testDirectoryPath: string): Promise<string> {
  const dree = getDirectoryTree(testDirectoryPath)
  let text = await buildSchemaForDirectoryTree(dree, "MyTestDirectory")

  const options = await resolveConfig(__filename)
  text = await format(text, { ...options, parser: "typescript" })

  return text
}
